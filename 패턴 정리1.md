## 싱글턴 패턴

#### 정의

- 전역 변수를 사용하지 않고 객체를 하나만 생성

  - 생성된 객체를 어디에서든지 참조할 수 있다.

- 하나의; 인스턴스만을 생성하는 책임이 있다.

  - `getInstance` 메서드를 통해 동일한 인스턴스를 반환

- 생성자가 `private`로 지정

- ```java
  public class singleton {
  	private static singleton_object = null;
  	
      // 외부에서 객체 생성 불가
  	private static singleton(){}
  	
      // 클래스의 로딩 시점에 한 번만 호출된다.
      // final 키워드로 값 재할당 방지
      private static class LazyHolder {
          public static final singleton INSTANCE = new singleton();
      }
      
  	public static singleton getInstance(){
  		return LazyHolder.INSTANCE;
  	}
  }
  ```



#### 싱글턴 패턴의 장점

- 고정된 메모리 영역을 사용하도록 단 한번 `new` 연산자로 인스턴스를 얻어오기 때문에 메모리의 낭비를 줄인다.
- 전역변수로 선언되고 전역 메서드로 호출 하기 때문에 다른 클래스에서 사용하기 쉽다.
- 공통된 객체를 사용해야 할 때에는 객체를 매번 생성하지 않기 때문에 성능면에서 훌륭하다.



#### 싱글턴 패턴의 단점

- 싱글톤 인스턴스가 너무 많은 일을 하거나 많은 데이터를 공유시킬 경우에는 다른 클래스의 인스턴스들 간의 결합도가 높아져 *개방-폐쇄 원칙* 을 위배
  - 수정이 어려워 지고 테스트하기 어려워진다.
- 멀티스레드 환경에서 동기화 처리를 안하면 인스턴스가 2개가 생성될 수 있다.



---



## 템플릿 메서드 패턴

#### 정의

- 어떤 작업을 처리하는 일부분을 **서브 클래스로 캡슐화**해 전체 일을 수행하는 구조는 바꾸지 않으면서 특정 단계에서 수행하는 내역을 바꾸는 패턴
  - 전체적으로는 동일하면서 부분적으로는 다른 구문으로 구성된 메서드의 코드 중복을 최소화
- 동일한 기능을 상위 클래스에서 정의
  - 확장/변화가 필요한 부분만 서브 클래스에서 구현
  - 전체적인 알고리즘 코드를 재사용하는 데 유용하도록 한다.
- 전체적인 레이아웃을 통일 시키지만 상속받은 클래스로 하여금 어느정도 유연성을 주도록 하는 디자인 패턴



#### AbstractClass

```java
public abstract class Student {
	void readyToStudy(){
        ready();
        getEquipment();
        studying();
        if(extraEquipment()){
            addEquipment();
        }
	}
	
    // final을 선언하여 상속받은 클래스는 수정 불가
	final void ready(){
		System.out.println("공부 준비");
	}
	
	abstract void getEquipment();
	
	abstract void studying();
    
    // hook 메소드 (상속받은 클래스는 선택적으로 메소드를 작서할 수 있다.)
    boolean extraEquipment(){
        return false;
    }
    
    // hook 메소드 (상속받은 클래스는 선택적으로 메소드를 작서할 수 있다.)
    void addEquipment(){};
}
```

#### ConcreteClass (상속 받는 클래스)

```java
public class major_computer extends Student {
	@Override
    void getEquipment(){
        System.out.println("컴퓨터, 모니터 셋팅");
    };
    
    @Override
    void studying(){
        System.out.println("컴퓨터, 모니터를 사용하여 공부 시작");
    };
    
    @Override
    boolean extraEquipment(){
        return true;
    }
    
    @Override
    void addEquipment(){
        System.out.println("더블 모니터 사용을 위해 모니터 추가 셋팅");
    }
}

public class major_piano extends Student {
    @Override
    void getEquipment(){
        System.out.println("피아노 셋팅");
    };
    
    @Override
    void studying(){
        System.out.println("피아노를 사용하여 공부 시작");
    };
}
```

---

#### 옵저버 패턴

- 한 객체의 상태 변화에 따라 다른 객체의 상태도 연동되도록 일대다 객체 의존 관계를 구성하는  패턴
- 데이터의 변경이 발생했을 경우 상대 클래스나 객체에 의존하지 않으면서 데이터 변경을 통보
- 상태를 가지고 있는 **주체 객체-publisher** + 상태의 변경을 알아야 하는 **관찰 객체-observer**
  - 관계는 1:1 또는 1:N



#### 구성

![observer pattern에 대한 이미지 검색결과](http://www.programmergirl.com/wp-content/uploads/2019/08/TheObserverPattern.png)

- Subject (**interface**)
  - `ConcreteObserver` 객체를 관리하는 요소
  - `Observer 인터페이스`를 참조해서 `ConcreteObserver`를 관리하므로 `ConcreteObserver`의 변화에 독립적일 수 있다.
- SubjectImpl(*ConcreteSubject*) (**class**)
  - 변경 관리 대상이 되는 데이터가 있는 클래스(통보하는 클래스)
  - 데이터 변경을 위한 메서드인 `setState`가 있다.
  - `setState` 메서드에서는 자신의 데이터인 `subjectState`를 변경하고 `Subject`의 `notifyAll` 메서드를 호출해서 `ConcreteObserver`객체에 변경을 통보한다
- Observer (**interface**)
  - 데이터의 변경을 통보 받는 인터페이스
  - `Subject`에서 `Observer 인터페이스`의 메소드를 호출하여 `SubjectImpl`의 데이터 변경을 `ConcreteObserver`에게 통보
- ConcreteObserver (**class**)
  - `SubjectImpl`의 변경을 통보받는 클래스
  - `Observer 인터페이스`의 `update 메서드`를 구현함으로써 변경을 통보받는다.
  - 변경된 데이터는 `SubjectImpl`의 `getState` 메서드를 호출함으로써 변경을 조회한다.



#### 실행 순서

1. `Subject` 인터페이스를 상속받는 클래스(`SubjectImpl`) 생성

2. `Observer`를 상속받는 `ConcreteObserver` 클래스 생성

   - 클래스를 생성할 때 1번에서 만든 SubjectImpl을 파라미터로 전달
   - 전달 후 `subjectImpl.add(this)` 등과 같은 메소드로 observer 등록
   - `ConcreteObserver` 클래스가 생성되면 `SubjectImpl`클래스에서 observer를 관리

3. `SubjectImpl`에서 새로운 data를 생성하면 `notifyObserver` 메소드를 통해 observer들에게 알린다.

   - `notifyObserver` 메소드 

     ```java
     @Override
     public void notifyObserver() {
         for (Observer observer : observers) {
             observer.update(data);
         }
     }
     ```

   - 2번에서 생성한 `ConcreteObserver` 객체는 각 객체의 `update` 메소드로 data 변경을 확인

     ```java
     @Override
     public void update(Object data) {
     	this.data = data;
     }
     ```

     



---

참조 

- https://gmlwjd9405.github.io/2018/07/13/template-method-pattern.html
- https://gmlwjd9405.github.io/2018/07/08/observer-pattern.html